#!/usr/bin/env python3

import argparse
import os
import re
import requests
import sys

from bs4 import BeautifulSoup
from shutil import which
from tqdm import tqdm
from tqdm import tqdm
from urllib.parse import urljoin, urlparse

def extract_model_info(model_path):
    if model_path.startswith("https://huggingface.co/"):
        parts = model_path.split("/")
        author, model = parts[3], parts[4]
    elif "/" in model_path:
        author, model = model_path.split("/")
    else:
        return None, model_path

    return author, model

def find_quant_repo(author, model):
    model = re.sub(r'-?gguf$', '', model, flags=re.IGNORECASE)
    base_urls = [
        f"https://huggingface.co/bartowski/{model}-GGUF/tree/main",
        f"https://huggingface.co/mradermacher/{model}-GGUF/tree/main",
        f"https://huggingface.co/mradermacher/{model}-i1-GGUF/tree/main",
        f"https://huggingface.co/{author}/{model}-GGUF/tree/main",
        f"https://huggingface.co/{author}/{model}-gguf/tree/main",
    ]
    
    for url in base_urls:
        response = requests.get(url)
        if response.status_code == 200:
            return url

    quants_url = f"https://huggingface.co/models?other=base_model:quantized:{author}%2F{model}&sort=downloads"
    response = requests.get(quants_url)
    if response.status_code == 200:
        soup = BeautifulSoup(response.text, 'html.parser')
        gguf_repo = soup.select_one('a.p-2[href*="gguf" i]')
        if gguf_repo:
            return urljoin("https://huggingface.co", gguf_repo['href'])

    raise Exception(f"No GGUF quants found.")

def get_quant_download_link(model_path, quant_type):
    author, model = extract_model_info(model_path)
    url = find_quant_repo(author, model)

    response = requests.get(url)
    if response.status_code == 200:
        pattern = f'href="([^"]*{re.escape(quant_type)}[^"]*)"'
        match = re.search(pattern, response.text, re.IGNORECASE)
        if match:
            quant_url = urljoin(url, match.group(1))
            if quant_url.lower().endswith(".gguf"):
                return quant_url.replace("/blob/", "/resolve/")
            else:
                raise Exception(f"This quant ({quant_url}) appears to be stored in a separate folder, so it is likely split across several files. good luck")

    raise Exception(f"Quant type '{quant_type}' not found in {url}.")

def download_quant(model_path, quant_type):
    download_dir = os.path.join(os.path.expanduser("~"), "Downloads")
    os.makedirs(download_dir, exist_ok=True)

    quant_url = get_quant_download_link(model_path, quant_type)
    file_name = os.path.basename(urlparse(quant_url).path)
    file_path = os.path.join(download_dir, file_name)

    if os.path.exists(file_path):
        print(f"File already exists: {file_path}")
        return os.path.abspath(file_path)
    
    download_file(quant_url, file_path)

    return os.path.abspath(file_path)

def download_file(url: str, file_path: str = None) -> str:
    with requests.get(url, stream=True, allow_redirects=True) as response:
        response.raise_for_status()  # Raise an exception for bad status codes
        total_size = int(response.headers.get('content-length', 0))
        
        if file_path is None:
            file_name = os.path.basename(urlparse(url).path)
            
            downloads_folder = os.path.join(os.path.expanduser('~'), 'Downloads')
            file_path = os.path.join(downloads_folder, file_name)
        else:
            file_name = os.path.basename(file_path)

        # Ensure the directory exists
        os.makedirs(os.path.dirname(file_path), exist_ok=True)

        with open(file_path, 'wb') as file, tqdm(
            desc=file_name,
            total=total_size,
            unit='iB',
            unit_scale=True,
            unit_divisor=1024,
        ) as progress_bar:
            for chunk in response.iter_content(chunk_size=8192):
                size = file.write(chunk)
                progress_bar.update(size)
    print(f"Download complete: {file_path}")

    return file_path

def main():
    class ArgumentParserShowHelp(argparse.ArgumentParser):
        def error(self, message):
            sys.stderr.write(f'error: {message}\n\n')
            self.print_help()
            sys.exit(2)

    parser = ArgumentParserShowHelp(
        description="Download and optionally run a quantized model.",
        usage="%(prog)s <model_path> [quant_type] [-n/--no-run] [kobold_args]"
    )
    parser.add_argument("model_path", help="the path to the model on Hugging Face, e.g. \"meta-llama/Meta-Llama-3-8B\"")
    parser.add_argument("quant_type", nargs="?", default="Q5_K_M", help="(optional) the quantization type, e.g. \"Q4_K_M\"; can be any string. Default: Q5_K_M")
    parser.add_argument("-n", "--no-run", action="store_false", dest="run", help="do not run the model after downloading")
    parser.add_argument("kobold_args", nargs=argparse.REMAINDER, help="additional arguments to pass to KoboldCpp")

    args = parser.parse_args()

    model_path = download_quant(args.model_path, args.quant_type)

    if args.run:
        download_dir = os.path.join(os.path.expanduser("~"), "Downloads")

        kobold_path = next((exe for exe in os.get_exec_path() if exe.startswith("koboldcpp")), None)
        if not kobold_path:
            kobold_path = next((os.path.join(download_dir, f) for f in os.listdir(download_dir) if f.startswith("koboldcpp")), None)

        if not kobold_path:
            print("koboldcpp not found. Downloading...")
            kobold_path = download_file("https://github.com/LostRuins/koboldcpp/releases/latest/download/koboldcpp-linux-x64-cuda1210")

        if not os.access(kobold_path, os.X_OK):
            os.chmod(kobold_path, os.stat(kobold_path).st_mode | 0o111)

        print(f"Using KoboldCpp at: {kobold_path}")

        kobold_args = ' '.join(args.kobold_args)
        kobold_cmd = f"{kobold_path} --model {model_path} {kobold_args}"
        print(kobold_cmd)

        os.system(kobold_cmd)

if __name__ == "__main__":
    main()
